1️⃣ Install dependencies

cd server
source .venv/bin/activate

Install FastAPI DB tools:
pip install sqlmodel psycopg[binary] sqlalchemy asyncpg
Explanation:
sqlmodel → simplifies SQLAlchemy with Pydantic models
psycopg[binary] → PostgreSQL driver
asyncpg → async driver for PostgreSQL
sqlalchemy → underlying ORM

2️⃣ Make sure PostgreSQL is running

Install PostgreSQL if you haven’t:
sudo apt update
sudo apt install postgresql postgresql-contrib
psql --version

Start PostgreSQL:
sudo service postgresql start
sudo systemctl start postgresql
sudo systemctl status postgresql ---> check if running
sudo systemctl stop postgresql
sudo systemctl restart postgresql
sudo systemctl enable postgresql ---> enable on boot
sudo systemctl disable postgresql

Create a database and user:
sudo -u postgres psql
# Inside psql:
CREATE DATABASE fastapi_db;
CREATE USER fastapi_user WITH PASSWORD 'mypassword';
GRANT ALL PRIVILEGES ON DATABASE fastapi_db TO fastapi_user;
GRANT ALL PRIVILEGES ON SCHEMA public TO fastapi_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO fastapi_user;
\q

Your connection string will look like:
postgresql+asyncpg://fastapi_user:mypassword@localhost/fastapi_db

3️⃣ Create a SQLModel model
In models.py:
from sqlmodel import SQLModel, Field

class Item(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str
    description: str | None = None

4️⃣ Setup database connection
In database.py:
from sqlmodel import SQLModel, create_engine
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "postgresql+asyncpg://fastapi_user:mypassword@localhost/fastapi_db"

engine = create_async_engine(DATABASE_URL, echo=True)
async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(SQLModel.metadata.create_all)

5️⃣ Use it in FastAPI
from fastapi import FastAPI, Depends
from sqlmodel import select
from sqlalchemy.ext.asyncio import AsyncSession
from database import async_session, init_db
from models import Item

app = FastAPI()

@app.on_event("startup")
async def on_startup():
    await init_db()

async def get_session() -> AsyncSession:
    async with async_session() as session:
        yield session

@app.post("/items/")
async def create_item(item: Item, session: AsyncSession = Depends(get_session)):
    session.add(item)
    await session.commit()
    await session.refresh(item)
    return item

@app.get("/items/")
async def read_items(session: AsyncSession = Depends(get_session)):
    result = await session.execute(select(Item))
    items = result.scalars().all()
    return items

6️⃣ Test it

Start the server:
fastapi dev main.py

POST /items/ → send JSON like:
{
  "name": "Book",
  "description": "A cool book"
}
GET /items/ → returns all items from the DB.

///
psql -U fastapi_user -d fastapi_db -h localhost
for passwor ---> mypassword

6️⃣ Fix Error:
asyncpg.exceptions.InsufficientPrivilegeError: permission denied for schema public
What it means:
Your PostgreSQL user (fastapi_user) doesn’t have permission to create tables in the public schema of your database. So when SQLModel tries to do CREATE TABLE item(...), PostgreSQL blocks it.
1. Connect as the postgres superuser:
sudo -u postgres psql
2. Grant privileges to your user:
-- Switch to your database
\c fastapi_db

-- Give all privileges on the database
GRANT ALL PRIVILEGES ON DATABASE fastapi_db TO fastapi_user;

-- Give all privileges on the public schema (important!)
GRANT ALL PRIVILEGES ON SCHEMA public TO fastapi_user;

-- Optional: allow future tables in public schema
ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT ALL ON TABLES TO fastapi_user;

\q


////
This setup gives you:
Async PostgreSQL connection
SQLModel ORM with Pydantic validation
FastAPI endpoints reading/writing to DB

////
Architecture Diagram (Conceptual)

        ┌───────────────┐
        │   Client      │
        │ (Browser /    │
        │  Postman /    │
        │  Frontend)    │
        └───────┬───────┘
                │ HTTP Request (GET / POST)
                ▼
        ┌───────────────┐
        │   FastAPI     │
        │  Endpoints    │
        └───────┬───────┘
                │ Depends injection
                ▼
        ┌───────────────┐
        │ SQLModel ORM  │
        │   Models      │
        └───────┬───────┘
                │ Async SQL queries
                ▼
        ┌───────────────┐
        │ PostgreSQL DB │
        │   Tables      │
        └───────────────┘

Step-by-step Flow

1. Client sends HTTP request

Example: POST /items/ with JSON payload

2. FastAPI Endpoint receives request

Validates data using Pydantic (from SQLModel model)

Calls Depends(get_session) to get an async DB session

3. SQLModel handles ORM mapping

Converts Python object (Item) into SQL INSERT/SELECT statements

4. Async session communicates with PostgreSQL

asyncpg driver sends SQL commands asynchronously

FastAPI can handle other requests while waiting

5. PostgreSQL executes query

Writes/reads data from the database

Returns results to SQLModel → FastAPI

6. FastAPI returns response to client

Pydantic ensures proper JSON output


💡 Key points:
async_session allows non-blocking DB calls, perfect for high concurrency
SQLModel combines Pydantic + SQLAlchemy ORM → validation + DB mapping in one
FastAPI + async DB keeps server fast and scalable