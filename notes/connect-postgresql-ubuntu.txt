1ï¸âƒ£ Install dependencies

cd server
source .venv/bin/activate

Install FastAPI DB tools:
pip install sqlmodel psycopg[binary] sqlalchemy asyncpg
Explanation:
sqlmodel â†’ simplifies SQLAlchemy with Pydantic models
psycopg[binary] â†’ PostgreSQL driver
asyncpg â†’ async driver for PostgreSQL
sqlalchemy â†’ underlying ORM

2ï¸âƒ£ Make sure PostgreSQL is running

Install PostgreSQL if you havenâ€™t:
sudo apt update
sudo apt install postgresql postgresql-contrib
psql --version

Start PostgreSQL:
sudo service postgresql start
sudo systemctl start postgresql
sudo systemctl status postgresql ---> check if running
sudo systemctl stop postgresql
sudo systemctl restart postgresql
sudo systemctl enable postgresql ---> enable on boot
sudo systemctl disable postgresql

Create a database and user:
sudo -u postgres psql
# Inside psql:
CREATE DATABASE fastapi_db;
CREATE USER fastapi_user WITH PASSWORD 'mypassword';
GRANT ALL PRIVILEGES ON DATABASE fastapi_db TO fastapi_user;
GRANT ALL PRIVILEGES ON SCHEMA public TO fastapi_user;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO fastapi_user;
\q

Your connection string will look like:
postgresql+asyncpg://fastapi_user:mypassword@localhost/fastapi_db

3ï¸âƒ£ Create a SQLModel model
In models.py:
from sqlmodel import SQLModel, Field

class Item(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    name: str
    description: str | None = None

4ï¸âƒ£ Setup database connection
In database.py:
from sqlmodel import SQLModel, create_engine
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "postgresql+asyncpg://fastapi_user:mypassword@localhost/fastapi_db"

engine = create_async_engine(DATABASE_URL, echo=True)
async_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)

async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(SQLModel.metadata.create_all)

5ï¸âƒ£ Use it in FastAPI
from fastapi import FastAPI, Depends
from sqlmodel import select
from sqlalchemy.ext.asyncio import AsyncSession
from database import async_session, init_db
from models import Item

app = FastAPI()

@app.on_event("startup")
async def on_startup():
    await init_db()

async def get_session() -> AsyncSession:
    async with async_session() as session:
        yield session

@app.post("/items/")
async def create_item(item: Item, session: AsyncSession = Depends(get_session)):
    session.add(item)
    await session.commit()
    await session.refresh(item)
    return item

@app.get("/items/")
async def read_items(session: AsyncSession = Depends(get_session)):
    result = await session.execute(select(Item))
    items = result.scalars().all()
    return items

6ï¸âƒ£ Test it

Start the server:
fastapi dev main.py

POST /items/ â†’ send JSON like:
{
  "name": "Book",
  "description": "A cool book"
}
GET /items/ â†’ returns all items from the DB.

///
psql -U fastapi_user -d fastapi_db -h localhost
for passwor ---> mypassword

6ï¸âƒ£ Fix Error:
asyncpg.exceptions.InsufficientPrivilegeError: permission denied for schema public
What it means:
Your PostgreSQL user (fastapi_user) doesnâ€™t have permission to create tables in the public schema of your database. So when SQLModel tries to do CREATE TABLE item(...), PostgreSQL blocks it.
1. Connect as the postgres superuser:
sudo -u postgres psql
2. Grant privileges to your user:
-- Switch to your database
\c fastapi_db

-- Give all privileges on the database
GRANT ALL PRIVILEGES ON DATABASE fastapi_db TO fastapi_user;

-- Give all privileges on the public schema (important!)
GRANT ALL PRIVILEGES ON SCHEMA public TO fastapi_user;

-- Optional: allow future tables in public schema
ALTER DEFAULT PRIVILEGES IN SCHEMA public
GRANT ALL ON TABLES TO fastapi_user;

\q


////
This setup gives you:
Async PostgreSQL connection
SQLModel ORM with Pydantic validation
FastAPI endpoints reading/writing to DB

////
Architecture Diagram (Conceptual)

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Client      â”‚
        â”‚ (Browser /    â”‚
        â”‚  Postman /    â”‚
        â”‚  Frontend)    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ HTTP Request (GET / POST)
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   FastAPI     â”‚
        â”‚  Endpoints    â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ Depends injection
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ SQLModel ORM  â”‚
        â”‚   Models      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ Async SQL queries
                â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ PostgreSQL DB â”‚
        â”‚   Tables      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step-by-step Flow

1. Client sends HTTP request

Example: POST /items/ with JSON payload

2. FastAPI Endpoint receives request

Validates data using Pydantic (from SQLModel model)

Calls Depends(get_session) to get an async DB session

3. SQLModel handles ORM mapping

Converts Python object (Item) into SQL INSERT/SELECT statements

4. Async session communicates with PostgreSQL

asyncpg driver sends SQL commands asynchronously

FastAPI can handle other requests while waiting

5. PostgreSQL executes query

Writes/reads data from the database

Returns results to SQLModel â†’ FastAPI

6. FastAPI returns response to client

Pydantic ensures proper JSON output


ğŸ’¡ Key points:
async_session allows non-blocking DB calls, perfect for high concurrency
SQLModel combines Pydantic + SQLAlchemy ORM â†’ validation + DB mapping in one
FastAPI + async DB keeps server fast and scalable